#### 思考题1

**查阅资料，了解 Linux/Unix 的 /proc 文件系统是什么？有什么作用？ Windows 操作系统又是如何实现这些功能的？proc 文件系统这样的设计有什么好 处和可以改进的地方？**

proc是一种伪文件系统，通过模拟文件系统来获取和修改内核的运行信息。windows操作系统则是通过系统调用的方式来实现这些功能。proc这样设计使得用户可配合文本处理命令来对内核信息进行修改和查询，更为灵活。



#### 思考题2

**如果我们通过 kseg0 读写设备，我们对于设备的写入会缓存到 Cache 中。通过 kseg0 访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如 我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。**

无法即时获取设备信息，导致信息不可靠。对于磁盘可以通过缓存访问，而对于串口设备每次访问必须刷新缓存。



#### 思考题3

**一个磁盘块最多存储 1024 个指向其他磁盘块的指针，试计算，我们 的文件系统支持的单个文件的最大大小为多大？**

单文件最多支持1024个逻辑磁盘块空间,为1024^2*4=4M大小



#### 思考题4

**查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件 控制块？一个目录下最多能有多少个文件？**

一个文件控制块为256B，一个逻辑磁盘块能存储16个文件控制块,一个目录最大4M空间,能够有16K个文件



#### 思考题5

**请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？**

1GB



#### 思考题6

**如果将 DISKMAX 改成 0xC0000000, 超过用户空间，我们的文件系统还能正常工作吗？为什么？**

不能，磁盘块会对kseg0的访问会不通过页表，直接访问内核空间。



#### 思考题7

**阅读 user/file.c ，你会发现很多函数中都会将一个 struct Fd \* 型的 指针转换为 struct Filefd \* 型的指针，请解释为什么这样的转换可行。**

```c
struct Filefd {
	struct Fd f_fd;
	u_int f_fileid;
	struct File f_file;
};
```



Filefd结构体内部初始存放有Fd结构体，两者指针应该指向同一位置，Filefd相当于对Fd的延拓。所以可以这样转换。



#### 思考题8

**请解释 Fd, Filefd, Open 结构体及其各个域的作用。比如各个结构体 会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明 形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系 与设计框架。**

```C
struct Fd {
	u_int fd_dev_id;  //打开的文件设备号,在read,write中需要使用
	u_int fd_offset;  //打开文件的偏移,在read,write等中会使用
	u_int fd_omode;   //打开文件的模式，在read，write中会使用
};
struct Filefd {
	struct Fd f_fd; //打开文件的描述符
	u_int f_fileid; //打开文件的编号
	struct File f_file; //打开文件的文件控制块
};
struct Open {
	struct File *o_file;	// 打开文件的文件控制块
	u_int o_fileid;			// 打开文件的id
	int o_mode;				// 打开文件模式
	struct Filefd *o_ff;	// 打开文件的文件描述符
};

```





#### 我认为的难点

我的难点主要有两方面。一方面在于逻辑块和实际物理块大小的混淆，实际上指导书有的地方写的有些模糊，特别时5.4.1描述磁盘结构时，说的是超级块放在第二个扇区(512Byte)，而在操作系统中我们的超级块实际上是放在第二个逻辑块上(4KB),这个对理解造成不小的困惑。第二个是理解serve通过ipc方式沟通的方法。



#### 心得体会

通过这次实验，我明白了文件系统的组织和架构，同时也学习到了结构体的拓展这种神奇的技巧。