#### 思考题1

**为什么我们在构造空闲进程链表时必须使用特定的插入的顺序？(顺序或者逆序)**

这样能保证每次env_alloc取出PCB块时也是有序的



#### 思考题2

**思考env.c/mkenvid 函数和envid2env 函数:**

**• 请你谈谈对mkenvid 函数中生成id 的运算的理解，为什么这么做？**

生产的id由两部分组成，高位表示第几次调用，低位表示进程在envs数组偏移，这样能够保证不同进程<br>的id不同，同时同一进程不同时刻调用的id也不同

**• 为什么envid2env 中需要判断e->env_id != envid 的情况？如果没有这步判断会发生什么情况？**

保证给到一个此id对应的PCB仍然指向次id对应的进程，否则过期id可能造成访问错误



#### 思考题3

**结合include/mmu.h 中的地址空间布局，思考env_setup_vm 函数：**

**• 我们在初始化新进程的地址空间时为什么不把整个地址空间的pgdir 都清零，而是复制内核的boot_pgdir作为一部分模板？(提示:mips 虚拟空间布局)**

所有进程共享内核，保证进程在内核态下能正确访问内核

**• UTOP 和ULIM 的含义分别是什么，在UTOP 到ULIM 的区域与其他用户区相比有什么最大的区别？**

UTOP应该是不同进程私有空间的顶端，ULIM则为内核开始的部分。UTOP到ULIM这一段包含内核页表信息、PCB控制块信息、用户自身页表信息。包含许多全局变量

**• 在env_setup_vm 函数的最后，我们为什么要让pgdir[PDX(UVPT)]=env_cr3?(提示: 结合系统自映射机制)**

这样相当于把所有的二级页表连续地映射到了User VPT 空间。

**• 谈谈自己对进程中物理地址和虚拟地址的理解**

我认为虚拟地址是对物理地址地映射，将物理地址上的不连续通过映射关系从而变为连续的手段。物理地址理解为原像，虚拟地址理解为像。



#### 思考题4

**思考user_data 这个参数的作用。没有这个参数可不可以？为什么？（如果你能说明哪些应用场景中可能会应用这种设计就更好了。可以举一个实际的库中的例子）**

给icode_mapper函数提供对应PCB块的访问接口，若没有在装载二进制文件时无法修改对应PCB页表。



#### 思考题5

**结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？ （提示：1、页面大小是多少；2、回顾lab1中的ELF文件解析，什么时候需要自动填充.bss段）**

可能面临：页面大小不是页对齐、装载地址不是页对齐、二进制文件filesizes和memsizes大小不等。



#### 思考题6

**思考上面这一段话，并根据自己在lab2 中的理解，回答：**

**• 我们这里出现的” 指令位置” 的概念，你认为该概念是针对虚拟空间，还是物理内存所定义的呢？**

虚拟空间所定义的

**• 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？**

不一样，每一个进程可以在不同的entry_point启动，属于进程的"个性化"设置，可在elf文件内修改。





#### 思考题7

**思考一下，要保存的进程上下文中的env_tf.pc的值应该设置为多少？为什么要这样设置？**

设置为env_tf.cp0_epc，此寄存器内存储了异常返回指令，用于异常结束后重入。



#### 思考题8

**Thinking 3.8 思考TIMESTACK 的含义，并找出相关语句与证明来回答以下关于TIMESTACK 的问题：**

**• 请给出一个你认为合适的TIMESTACK 的定义**

我认为TIMESTACK即为发生时钟中断异常时存储的上下文的栈

**• 请为你的定义在实验中找出合适的代码段作为证据(请对代码段进行分析)**

```c
.macro get_sp
	mfc0	k1, CP0_CAUSE
	andi	k1, 0x107C
	xori	k1, 0x1000
	bnez	k1, 1f
	nop
	li	sp, 0x82000000
	j	2f
	nop
1:
	bltz	sp, 2f
	nop
	lw	sp, KERNEL_SP
	nop

2:	nop


.endm

```

在stackframe.h中的SAVE_ALL函数中若发生时钟中断把当前所有的寄存器存入以为TIMESTACK为顶端的栈中

**• 思考TIMESTACK 和第18 行的KERNEL_SP 的含义有何不同**

TIMESTACK为时钟中断时保存上下文的栈结构，KERNEL_SP为其他中断时保存上下文的栈结构





#### 思考题9

 **阅读 kclock_asm.S  文件并说出每行汇编代码的作用**

```cpp
#include <asm/regdef.h>
#include <asm/cp0regdef.h>
#include <asm/asm.h>
#include <kclock.h>



.macro	setup_c0_status set clr
	.set	push
	mfc0	t0, CP0_STATUS
	or	t0, \set|\clr
	xor	t0, \clr
	mtc0	t0, CP0_STATUS			
	.set	pop
.endm

	.text
LEAF(set_timer)

	li t0, 0x01
	sb t0, 0xb5000100
	sw	sp, KERNEL_SP
setup_c0_status STATUS_CU0|0x1001 0
	jr ra

	nop
END(set_timer)
```

首先向0xb5000100 位置写入1，偏移量为0x100 表示来设置实时钟中断的频率，1 则表示1 秒钟中断1次，如果写入0，表示关闭实时钟。然后再设置CP0_SR寄存器的相应位置，开启全局中断(同时使得中断允许，并设置位于用户模)式下。





#### 思考题10

**阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。**

在本实验中是根据时钟中断的方式+进程优先级的方式来调度，每次时钟中断产生后先判断当前剩余时钟片是否

为0，若不为零则继续允许，否则切换进程。



#### 我认为的难点

代码中涉及许多C语言内嵌汇编的情况，加上对GNU汇编和硬件原理不熟悉，理解代码要花许多时间。



#### 我的心得体会

对于地址有了更进一步的理解，明白只能通过虚地址再加上机器上的自动转换机制来进行访问，C语言中空间和机器中的空间认识也更加深刻了。

